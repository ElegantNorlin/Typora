---

---



### 什么是死锁？

计算机系统中有很多独占性资源，比如打印机就是独占性资源，一台打印机同一时刻只能被一个进程所占用，**如果同一时刻有两个打印机输出结果，可能会引起文件系统的瘫痪。**

两个进程独占性的访问某个资源，从而等待另外一个资源的执行结果，会导致两个进程都被阻塞，并且两个进程都不会释放各自的资源，这种情况就是死锁（deadlock）。

⚠️：死锁可以发生在任何层面，在不同的机器之间可能会发生死锁，在数据库系统中也会导致死锁，比如进程 A 对记录 R1 加锁，进程 B 对记录 R2 加锁，然后进程 A 和 B 都试图把对象的记录加锁，这种情况下就会产生死锁。

### 资源死锁产生的条件

* 互斥条件：每个资源都被分配给了一个进程或者资源是可用的
* 保持和等待条件：已经获取资源的进程被认为能够获取新的资源
* 不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放
* 循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。

⚠️：发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁。

### 处理死锁的策略

* 忽略死锁带来的影响（惊呆了）

  最简单的解决办法就是使用鸵鸟算法(ostrich algorithm)，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。

* 检测死锁并恢复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题

  * 每种资源中仅有一个资源的死锁检测：

    ![img](https://gitee.com/wanwanzh/imagebed/raw/master/pictures/b1fa0453-a4b0-4eae-a352-48acca8fff74.png) 

    上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

    图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

    每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

  * 每种类型多个资源的死锁检测：

    ![img](https://gitee.com/wanwanzh/imagebed/raw/master/pictures/A6IbTS.png) 

    每个资源类用一个方框表示，方框中的原点表示此资源类中的各个资源；

    每个进程用一个圆圈来表示，用有向边表示进程申请资源和资源分配情况。

    约定方框→圆圈表示资源分配，圆圈→方框表示申请资源。

    这种情况下，图3-6 发生了死锁，而图3-7没有发生死锁。

  * 死锁恢复：

    * 通过抢占进行恢复：

      在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。

    * 通过回滚进行恢复：

      如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含存储映像(memory image)，还包含资源状态(resource state)。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。

      为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。

    * 杀死进程恢复：

      最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。

    ⚠️：另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。

* 通过仔细分配资源来避免死锁

  * 单个资源的银行家算法

    银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。

    比如下面的例子，银行家一共为所有城镇居民提供了 15 单位个贷款额度，一个单位表示 1k 美元，如下所示

    <img src="https://gitee.com/wanwanzh/imagebed/raw/master/pictures/1612666769-uDVAHa-os6-12.png" alt="os6-12.png" style="zoom:67%;" /> 

    城镇居民都喜欢做生意，所以就会涉及到贷款，每个人能贷款的最大额度不一样，在某一时刻，A/B/C/D 的贷款金额如下

    <img src="https://gitee.com/wanwanzh/imagebed/raw/master/pictures/1612666772-quvGEK-os6-13.png" alt="os6-13.png" style="zoom:67%;" /> 

    上面每个人的贷款总额加起来是 13，马上接近 15，银行家只能给 A 和 C 进行放贷，可以拖着 B 和 D、所以，可以让 A 和 C 首先完成，释放贷款额度，以此来满足其他居民的贷款。这是一种安全的状态。

    如果每个人的请求导致总额会超过甚至接近 15 ，就会处于一种不安全的状态，如下所示

    <img src="https://gitee.com/wanwanzh/imagebed/raw/master/pictures/1612711060-PULWoQ-os6-14.png" alt="os6-14.png" style="zoom:67%;" /> 

    这样，每个人还能贷款至少 2 个单位的额度，如果其中有一个人发起最大额度的贷款请求，就会使系统处于一种死锁状态。

    这里注意一点：不安全状态并不一定引起死锁，由于客户不一定需要其最大的贷款额度，但是银行家不敢抱着这种侥幸心理。

    银行家算法就是对每个请求进行检查，检查是否请求会引起不安全状态，如果不会引起，那么就接受该请求；如果会引起，那么就推迟该请求。

    类似的，还有多个资源的银行家算法，读者可以自行了解。

* 通过破坏死锁产生的四个条件之一来避免死锁

  * 破坏互斥条件

    我们首先考虑的就是破坏互斥使用条件。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 假脱机打印机(spooling printer) ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。

    后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。

    因此，尽量做到尽可能少的进程可以请求资源。

  * 破坏保持等待的条件

    第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。

    很多进程无法在执行完成前就知道到底需要多少资源，如果知道的话，就可以使用银行家算法；还有一个问题是这样无法合理有效利用资源。

    还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。

  * 破坏不可抢占条件

    破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。

  * 破坏循环等待条件

    现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。

    另一种方式是将所有的资源统一编号，如下图所示

    <img src="https://gitee.com/wanwanzh/imagebed/raw/master/pictures/1612666775-DOzJmV-os6-15.png" alt="os6-15.png" style="zoom:67%;" /> 

    进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。

    <img src="https://gitee.com/wanwanzh/imagebed/raw/master/pictures/1612666778-ROTjRQ-os6-16.png" alt="os6-16.png" style="zoom:67%;" /> 

    尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。

