---
title: JVM内存回收机制
date: 2022-04-04
tags: 
- Java
- JVM
---



### 1.学习JVM的意义是什么？

* 高频面试题
* 排查一些程序log日志中无法呈现的问题
* 理解GC原理，解决性能问题
* 理解JVM的内存结构，必要时堆JVM进行调优

### 2.JDK&JRE&JVM的关系

范围：JDK>JRE>JVM

* JVM（Java Virtual Machine）为Java虚拟机。

* JRE包含了JVM，并且包括了运行所依赖的类库（jar包等文件）。

* JDK除了包含JRE，还含有对于开发人员需要的编译工具和反编译工具。

### 3.JVM运行时内存结构

![](https://github.com/ElegantNorlin/Images/blob/main/images/JVMRuntimeStructure.png?raw=true)



方法区和堆区是所有线程共享的，称为线程共享区。

其他区域不共享线程，称为线程独立区。

#### 3.1程序计数器

* 程序计数器是一小块内存区域，可以看作当前线程执行字节码的行号指示器，字节码解释工作是通过改变这个计数器的值来执行操作。

* 每条线程都需要自己独立的程序计数器，多条线程计数器之间不互相影响，独立存储。我们称这类内存区域为**线程私有的**内存区域。

* 此内存区域是Java虚拟机中唯一一个没有规定任何OutOfMemoryError的内存区域。

#### 3.2Java虚拟机栈（栈区、栈内存）

* Java虚拟机栈也是线程私有的，生命周期与线程相同。每个方法在在执行的时候都会创建一个栈帧。

* 栈帧中包含了局部变量表和操作数栈。操作数栈可以理解为一个包含了接下来要操作的字节码指令序号的栈。每执行一个字节码指令，操作数栈都会弹栈该字节码指令序号。

* Java虚拟机栈是用来执行Java方法的。而本地方法栈是用来执行Java内置方法，这个方法可能是C语言实现的等等。在程序的执行过程避免不了方法调用方法，也就不可避免的出现Java虚拟机栈和本地方法栈之间的通信（通过JNI本地方法接口）。

* 如果线程在栈中申请的深度大于虚拟机所允许的深度，将出现StackOverFlowError异常;如果扩展无法申请到足够的内存， 就会抛出OutOfMemoryError异常。

#### 3.3方法区

* 方法区与Java堆都是线程共享区。

* 用于存储类的修饰符、权限、继承关系、接口列表、字段信息，声明的顺序、修饰符、类型、名字，方法的修饰符、返回值、名字、参数列表、抛出的异常、方法字节码指令、静态变量。

* 常量池存在方法区中。

* 方法区无法满足内存分配时，将抛出OutOfMemoryError异常。

#### 3.4常量池

* 用于存储常量。

* 用于存储字面量，比如“String s = “abc””，其中的“abc”为字面量。

#### 3.5堆区

![](https://github.com/ElegantNorlin/Images/blob/main/images/heap.png?raw=true)

* 堆区在内存中占用的空间最大。

* 堆区被所有线程共享。

* 所有的对象实例以及数组都要在堆上分配空间。

* Java堆事垃圾收集器管理的主要区域，因此很多时候被称为GC堆。

* 如果堆中没有足够的空间扩展，则会抛出OutOfMemoryError异常。

#### 3.6本地方法栈

* 本地方法栈是用来执行Java内置方法，这个方法可能是C语言实现的等等。

### 4.判断JVM内存中对象是否死亡的算法

#### 4.1引用计数算法

每一个对象都会有一个引用计数器，每当有一个引用指向该对象时，引用计数器就会+1，这样只要观察引用计数器数值大于0，就表示这个对象有人在使用，该对象还不能被回收；若引用计数器小于0，则该对象在垃圾回收时就会被GC回收掉。

缺点：

如果有两个对象都是垃圾且相互引用，那么这两个对象就的引用计数器就永远不为0，GC将无法将进行回收。



#### 4.2可达性分析算法

从整个堆内存的根对象（GC Roots）出发，看看有多少是可达的（字面意思是否可以到达、遍历到），有多少是不可达的。无法到达的就意味着无法访问，自然就是垃圾。



哪些对象可以作为根对象呢？

* 栈中引用的对象；
* 类静态属性引用的对象；
* 常量引用的对象；
* Native方法（JNI）引用的对象；

#### 4.3垃圾回收算法

##### 4.3.1Serial 收集器

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![](https://github.com/ElegantNorlin/Images/blob/main/images/serial.png?raw=true)

虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。

但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

##### 4.3.2ParNew

**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![](https://github.com/ElegantNorlin/Images/blob/main/images/ParNew.png?raw=true)

它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

**并行和并发概念补充：**

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

##### 4.3.3Parallel Scavenge收集器

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**

```text
-XX:+UseParallelGC

    使用 Parallel 收集器+ 老年代串行

-XX:+UseParallelOldGC

    使用 Parallel 收集器+ 老年代并行
```

**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![](https://github.com/ElegantNorlin/Images/blob/main/images/Parallel%20Scavenge.png?raw=true)



**这是 JDK1.8 默认收集器**

使用 java -XX:+PrintCommandLineFlags -version 命令查看

```text
-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC
java version "1.8.0_211"
Java(TM) SE Runtime Environment (build 1.8.0_211-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)
```

JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能



##### 4.3.4Serial Old收集器

**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

##### 4.3.5Parallel Old收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

##### 4.3.6CMS收集器

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![](https://github.com/ElegantNorlin/Images/blob/main/images/CMS.png?raw=true)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**



##### 4.3.7G1收集器

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

##### 4.3.8ZGC收集器

与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。

在 ZGC 中出现 Stop The World 的情况会更少！



